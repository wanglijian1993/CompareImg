# 通过OpenCv去计算二个图片的相似度
网上调研常用去比较图片相似度的算法有:均值哈希算法,感知哈希算法,差值哈希算法接下来挨个分析这三种算法去比较图片相似度的效果。
## 前期知识点
图片格式占用的位数
RGB888:每个像素用32比特位表示，占3个字节，RGB分量分别使用8位、8位、8位。
RGB565:每个像素用16比特位表示，占2个字节，RGB分量分别使用5位、6位、5位。
## 图像数据格式
RGB色彩模式是工业界的一种颜色标准，是通过对红、绿、蓝三原色进行组合得到各种各样不同颜色的表示。

## 均值哈希算法实现步骤

### 压缩图片
对图片进行8*8像素压缩
为什么要对图片进行压缩？
图片越大像素越大比较的时候计算耗时占用内存多，相反可以使二个图片宽高一样比较起来更方便，减少比较图片无效信息，图片越小比较速度越快。
### 对图片转灰色图
常见图片格式有PNG，JPG格式对应图片像是格式是RGB888,RGB565，我们需要对图片转换成单通道颜色更方便比较图片相似度。
### 计算平均像素值
通过矩阵计算出图片的平均像素值
### 计算指纹(二进制数据)
通过平均值和矩阵数据比较如果矩阵数据>平均值为1否则为0得到图片指纹数据，用于图片相似度比较。
### 理论实践
![使用图片](imgs/img1.jpg "红色汽车")

#### 压缩图片
[172, 148, 120, 217, 222, 218, 222, 222, 207, 216, 228, 230, 231, 229, 209, 202, 194, 170, 204, 186, 159, 191, 166, 140;
 210, 219, 221, 189, 166, 134, 207, 195, 177, 186, 165, 136, 187, 157, 122, 171, 134, 100, 164, 127,  93, 165, 127,  95;
 190, 160, 125, 190, 160, 125, 192, 162, 127, 194, 166, 135, 202, 181, 154, 214, 200, 172, 218, 203, 177, 223, 204, 177;
 217, 200, 179, 226, 209, 183, 179, 165, 216, 183, 171, 216, 235, 219, 183, 231, 208, 176, 229, 202, 168, 230, 205, 171;
 235, 209, 174, 143, 132,  98, 183, 163, 132,  88,  81, 238,  84,  72, 238,  81,  79, 232,  72,  58, 159, 126, 131, 145;
 194, 177, 236,  48,  65, 208,  44,  52, 196,  45,  50, 203,  46,  52, 203, 191, 184, 179,  15,   1,   2, 114, 108, 103;
 118, 106, 121, 107, 101,  93,  50,  38,  38,  12,   0,   1,  14,   0,   2,  93,  90,  86,  73,  70,  66,  89,  86,  82;
  86,  81,  78,  98,  93,  90,  95,  91,  86,  88,  84,  79,  92,  88,  83,  95,  91,  86,  94,  89,  86,  71,  66,  65]
我们图片是具有三颜色通道的得到的数据是32*8的像素数据

### 对图片转灰色图

[152, 220, 220, 225, 227, 194, 188, 171;
 217, 169, 197, 168, 162, 141, 134, 135;
 165, 165, 167, 171, 184, 201, 205, 207;
 203, 211, 175, 180, 220, 211, 206, 209;
 213, 131, 165, 101,  95,  97,  74, 131;
 189,  76,  66,  66,  67, 186,   5, 109;
 111, 102,  42,   4,   4,  90,  70,  86;
  82,  94,  92,  85,  89,  92,  90,  67]  
变换成但颜色通道  
![使用图片](imgs/garycar.jpeg "灰色汽车")

### 计算平均像素值
根据灰色图片矩阵像素计算均值a结果140.184。
### 计算指纹(二进制数据)
指纹:11111111111111100111111111111111110100000100001000000000000000000
### 图片比较效果
![图片1](imgs/img1.jpg "图片1")
![图片2](imgs/img2.jpg "图片2")

##### 直接展示结果
图片1指纹:1111111111111100111111111111111110100000100001000000000000000000  
图片2指纹:0001100000000000000000000000000000010000000111000001111101111111  
图片相似度数量:28.125%  
**结论:图片1和图片2我们看来是二个完全不同的图片，但是我们生成图片指令的时候其实就是非对即错因为指令是二进制数据，img1[i]=img2[i]就是相同否则就是不同，有一定量的相似度是正常的现象。**

## 感知哈希算法
### 压缩图片
对图片进行32*32像素压缩
### 对图片转灰色图
跟均值哈希算法一样
### 计算DCT(离散余弦计算)
openCV提供dct()函数
### 计算平均像素值
通过矩阵计算出图片的平均像素值(取8*8像素位置)
### 计算指纹(二进制数据)
跟均值哈希算法一样
## 差值哈希算法

### 压缩图片
对图片进行8*9像素压缩
### 对图片转灰色图
跟均值哈希算法一样
### 重新计算矩阵值
差值算法的核心就重新计算图片矩阵的值通过矩阵i+1的值减去矩阵i的值得到8*8矩阵新数据
### 计算平均像素值
通过矩阵计算出图片的平均像素值(取8*8像素位置)
### 计算指纹(二进制数据)
跟均值哈希算法一样

## 总结：均值算法跟感知算法结果比较相似，但是均值算法不需要对数据转换DCT性能比较好，差值的算法相似度的值较比其他二种算法的值得到的结果较低，比较适合图片差异化比较大的图片。
